<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="utf-8"/>
<title>Backpropagation</title>
<meta name="author" content="Lucas Sas Brunschier"/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="reveal/css/reveal.css"/>

<link rel="stylesheet" href="reveal/css/theme/solarized.css" id="theme"/>

<link rel="stylesheet" href="style.css"/>

<!-- If the query includes 'print-pdf', include the PDF print sheet -->
<script>
    if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = 'reveal/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    }
</script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="sec-title-slide">
<h1 class="title">Backpropagation</h1><h2 class="author">Lucas Sas Brunschier</h2><h2 class="date">SS20</h2><p class="date">Created: 2020-05-03 Sun 20:21</p>
</section>

<section>
<section id="slide-org9e06022">
<h2 id="org9e06022">Intro</h2>
<p>
Präsentation ist auch online <a href="https://sirbubbls.github.io/backpropagation-seminar">sirbubbls.github.io/backpropagation-seminar</a>
</p>

<p>
Präsentation ist in Org-Mode geschrieben, also sourcen aller Grafiken und
Beispiele sind integriert.
</p>
</section>
<section id="slide-org670b803">
<h3 id="org670b803">Zusätzliche Ressourcen</h3>
<p>
Deep Learning (Ian Goodfellow, Yoshua Bengio &amp; Aaron Courville)
</p>

<div class="figure">
<p><img src="https://images-eu.ssl-images-amazon.com/images/I/610HnULa0dL._SY445_QL70_ML2_.jpg" alt="610HnULa0dL._SY445_QL70_ML2_.jpg" width="150" />
</p>
</div>

<p>
<a href="https://www.deeplearningbook.org">https://www.deeplearningbook.org</a>
</p>

<p>
<a href="https://www.deeplearningbook.org/contents/mlp.html">Backpropagation Kapitel</a>
</p>

</section>
<section id="slide-orgd37db6a">
<h3 id="orgd37db6a">Jupyter Notebook</h3>
<p>
Beispiele für alle Methoden dieser Präsentation sind in diesem <a href="https://github.com/SirBubbls/backpropagation-seminar/blob/master/Backpropagation.ipynb">IPython Notebook</a> zu finden.
</p>
</section>
</section>
<section>
<section id="slide-org8c9c7ef">
<h2 id="org8c9c7ef">Historisches</h2>
<p>
Erste Verwendung in Zusammenhang mit artificial neural networks im Jahre 1985 im Buch &rsquo;Learning Logic&rsquo; (Parker, D.B.).
</p>

</section>
</section>
<section>
<section id="slide-orgc80f1d9">
<h2 id="orgc80f1d9">Vorwissen</h2>
<div class="outline-text-2" id="text-orgc80f1d9">
</div>
</section>
<section id="slide-org8888e8a">
<h3 id="org8888e8a">Gradient</h3>
<p>
Der Gradient ist der Vektor aller partiellen Ableitungen einer Funktion \(f\).
</p>
<blockquote>
<p>
Notation: \(\nabla_xf(x)\)
</p>
</blockquote>
</section>
<section id="slide-orgc8d2b6d">
<h4 id="orgc8d2b6d">Beispiel</h4>
<blockquote>
<p>
\(f(x, y) = 2x^2 + y^3\)
</p>
</blockquote>
<p>
\(\rightarrow \nabla_xf(x)=\left(\begin{array}{c} f'_x \\ f'_y \end{array}\right)= \left(\begin{array}{c} 4x \\ 3y \end{array}\right)\)
</p>
</section>
<section id="slide-orgd038d2d">
<h3 id="orgd038d2d">Stochastic Gradient Descent</h3>
<p>
Der Gradient Descent Algorithmus wird dafür verwendet ein lokales Minimum einer Funktion zu bestimmen.
</p>
</section>
<section id="slide-org3dd8bfe">
<h4 id="org3dd8bfe">Beispiel</h4>
<p>
Funktion \(f(x)=x_1^2-x_2^2\) ist gegeben. <br />
Also: \(\nabla_xf(x)=\left(\begin{array}{c} f'_{x_1} \\ f'_{x_2} \end{array}\right)= \left(\begin{array}{c} 2x_1 \\ -2x_2 \end{array}\right)\) <br />
Wir starten mit einem beliebigen Punkt: z.B. \(\left(\begin{array}{c} 2 \\ 1 \end{array}\right)\) und setzen ein: <br />
\(\left(\begin{array}{c} 2x_1 \\ -2x_2 \end{array}\right) = \left(\begin{array}{c} 2 * 2 \\ -2 * 1 \end{array}\right) = \left(\begin{array}{c} 4 \\ -2 \end{array}\right)\)
</p>

<p>
\(Neuer\ Punkt = \left(\begin{array}{c} 2 \\ 1 \end{array}\right)+ \lambda \left(\begin{array}{c} 4 \\ -2 \end{array}\right)\) mit \(\lambda: learning\ rate\)
</p>

</section>
</section>
<section>
<section id="slide-orga036db7">
<h2 id="orga036db7">Neuronale Netze</h2>
<p>
Formale Definition für ein neuronales Netz: \(y=f(x; \theta)\) und \(y=f^*(x)\)
</p>
<ul>
<li>\(y\) ist den Wert den unser NN vorraussagen soll</li>
<li>\(x\) sind die Input Daten, die das NN erhält</li>
<li>\(\theta\) sind Parameter des neuronalen Netzes, um \(f\) so nah wie möglich an
die optimale Funktion \(f^*\) anzunähern.</li>

</ul>
</section>
<section id="slide-org2722f3f">
<h3 id="org2722f3f">Wie ist nun ein neurales Netzwerk aufgebaut?</h3>
<p>
Wir teilen das Netzwerk in Schichten (Layer) auf.
</p>


<div class="figure">
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/3d/Neural_network.svg/1200px-Neural_network.svg.png" alt="1200px-Neural_network.svg.png" width="50%" height="50%" />
</p>
</div>

<p>
Jeder Layer bildet eine Funktion \(f^{i}\), mit \(i=Layer\ Index\) ab.
</p>

</section>
<section id="slide-org90ed312">
<h4 id="org90ed312">Formell</h4>
<p>
Somit ist ein neurales Netzwerk eine Kette an Funktionen \(f\).
</p>
<blockquote>
<p>
Ein Netz mit \(3\) Layern wäre somit \(f^2(f^1(f^0(X)))\)
mit \(X=Input\ Data\)
</p>
</blockquote>
</section>
<section id="slide-orgbd2ce6c">
<h4 id="orgbd2ce6c">Aufbau eines Layers</h4>
<p>
Jeder Layer enthält mindestens folgende Informationen:
</p>
<ul>
<li>Eine Weight Matrix (\(w\))</li>
<li>Einen Bias Vektor (\(b\))</li>

</ul>
</section>
<section id="slide-org9363382">
<h4 id="org9363382">Aktivierungsfunktion</h4>
<p>
Da wir bei Neural Networks oft versuchen non-lineare Zusammenhänge zu aproximieren, benötigen wir auch eine nicht-lineare Komponente in unserem NN.
</p>
</section>
<section id="slide-orgd48e732">
<h4 id="orgd48e732">Beliebte Aktivierungsfunktionen</h4>
<ul>
<li>Rectified Linear Unit (\(ReLU\))</li>
<li>\(Leaky\ ReLU\)</li>
<li>Sigmoid Function</li>

</ul>
</section>
<section id="slide-orged4ef7e">
<h4 id="orged4ef7e">Cost Function (\(J\))</h4>
<p>
Eine Funktion um zu bestimmen wie &rsquo;nah&rsquo; wir uns an unserem erwarteten Inference Wert befinden.
</p>
<blockquote>
<p>
In dieser Präsentation benutzen wir die Euklidean-Distance \((x-y)^2\) als Cost Function.
</p>
</blockquote>
</section>
</section>
<section>
<section id="slide-org59c8273">
<h2 id="org59c8273">Forward Propagation</h2>
<p>
Ein Layer in einem Feed-Forward Neural Network besteht aus folgenden Elementen:
</p>
<ul>
<li>Inputs (\(X\))</li>
<li>Weights (\(W\))</li>
<li>Biases (\(b\))</li>
<li>Output (\(a\))</li>

</ul>
</section>
<section id="slide-org86fd66a">
<h3 id="org86fd66a">Formell</h3>
<p>
Um die Aktivierungen (\(a\)) eines Layers zu berechen können wir folgende Formel benutzen:
</p>
<blockquote>
<p>
\(a_L = \sigma(a_{L-1} w_L + b_L)\)
</p>
</blockquote>
<p>
Der berechnete Vektor \(a_L\) dient dem Layer \(L+1\) als Input.
</p>
</section>
<section id="slide-org5b97efe">
<h3 id="org5b97efe">Beispiel (XOR)</h3>
<p>
\(W=\left[\begin{array}{ccc} 1 & 1 \\ 1 & 1 \end{array}\right]\) <br />
\(c=\left [\begin{array}{ccc} 0 \\ -1 \end{array} \right]\) <br />
</p>
</section>
<section id="slide-orga22df29">
<h3 id="orga22df29">Multiplizieren der Weights (\(W\)) und Inputs (\(X\))</h3>
<p>
\[
XW=\left[\begin{array}{ccc} 0 & 0 \\ 0 & 1 \\ 1 & 0 \\ 1 & 1 \end{array} \right]
\left[\begin{array}{ccc} 1 & 1 \\ 1 & 1 \end{array}\right]=
\left[\begin{array}{ccc} 0 & 0 \\ 1 & 1 \\ 1 & 1 \\ 2 & 2 \end{array} \right]
\]
</p>

</section>
<section id="slide-org5163f2a">
<h3 id="org5163f2a">Addieren des Bias Vektors (\(c\))</h3>
<p>
\[
XW + c=
\left[\begin{array}{ccc} 0 & 0 \\ 1 & 1 \\ 1 & 1 \\ 2 & 2 \end{array} \right] +
\left(\begin{array}{ccc} 0 \\ -1 \end{array}\right)=
\left[\begin{array}{ccc} 0 & -1 \\ 1 & 0 \\ 1 & 0 \\ 2 & 1 \end{array} \right]
\]
</p>
</section>
<section id="slide-org0041b36">
<h3 id="org0041b36">Aktivierungsfunktion (in diesem Fall \(ReLU\))</h3>
<blockquote>
<p>
\(ReLU:= f(x)=max(0, x)\)
</p>
</blockquote>
<p>
\[
relu(XW+c)=
relu(\left[\begin{array}{ccc} 0 & -1 \\ 1 & 0 \\ 1 & 0 \\ 2 & 1 \end{array} \right])=
\left[\begin{array}{ccc} 0 & 0 \\ 1 & 0 \\ 1 & 0 \\ 2 & 1 \end{array} \right]
\]
</p>

<p>
Die Aktivierungsfunktion wird auf jedes Element der Matrix ausgeführt.
</p>

</section>
<section id="slide-orgea7acb9">
<h3 id="orgea7acb9">Output Layer</h3>
<p>
Multiplizieren der Output Matrix des ersten Layers mit den Weights des Output Layers (\(w\)).
\[
w= relu(XW+c)* \left[\begin{array}{ccc} 1 \\ -2 \end{array}\right]=
\left[\begin{array}{ccc} 0 & 0 \\ 1 & 0 \\ 1 & 0 \\ 2 & 1 \end{array} \right]*
\left[\begin{array}{ccc} 1 \\ -2 \end{array}\right]=
\left[\begin{array}{ccc} 0 \\ 1 \\ 1 \\ 0 \end{array}\right]
\]
</p>
</section>
<section id="slide-orgfd0e655">
<h3 id="orgfd0e655">Predictions &amp; Input</h3>
<p>
Input: \(\left[\begin{array}{ccc} 0 & 0 \\ 0 & 1 \\ 1 & 0 \\ 1 & 1 \end{array} \right]\)
Predictions: \(\left[\begin{array}{ccc} 0 \\ 1 \\ 1 \\ 0 \end{array}\right]\)
</p>

</section>
<section id="slide-org892e4ac">
<h3 id="org892e4ac">Code Beispiel</h3>
<div class="org-src-container">

<pre  class="src src-python"><span style="color: #fb2874;">def</span> <span style="color: #b6e63e;">forward</span>(X):
    <span style="color: #fd971f;">a</span> = X
    <span style="color: #fb2874;">for</span> layer <span style="color: #fb2874;">in</span> L:
        <span style="color: #fd971f;">a</span> = h @ L.weights + L.bias
    <span style="color: #fb2874;">return</span> a
</pre>
</div>

</section>
</section>
<section>
<section id="slide-org1fd2176">
<h2 id="org1fd2176">Backpropagation</h2>
<div class="outline-text-2" id="text-org1fd2176">
</div>
</section>
<section id="slide-orgd3a30f1">
<h3 id="orgd3a30f1">Wozu brauchen wir den Backpropagation Algorithmus?</h3>
<p>
Ein fundamentaler Baustein, von neuralen Netzen.
</p>

<p>
Backpropagation ist kein Lernalgorithmus/Optimierungsalgorithmus, sondern aussschlißlich für die Generierung der Gradients jedes Layers zuständig.
</p>

<p>
Also suchen wir folgende Gradienten:
</p>
<ul>
<li>\(\nabla_{b^k} J\)</li>
<li>\(\nabla_{w^k} J\)</li>

</ul>

</section>
<section id="slide-org65008c6">
<h3 id="org65008c6">Ketten Regel</h3>
<aside class="notes">
<p>
Da ein NN prinzipiell nur viele geschachtelte Funktionen sind ist die Kettenregel sehr nützlich um die Ableitungen für jede Funktion zu bestimmen.
</p>

</aside>

<p>
Die Kettenregel ist nützlich um Ableitungen aus schon bereits vorhandenen Ableitungen zu konstruieren.
</p>

<p>
\[y=g(x)\ und\ z=f(g(x))=f(y)\]
</p>

<p>
Dann besagt die Kettenregel: \(\frac{dz}{dx} = \frac{dz}{dy} \frac{dy}{dx}\)
</p>

</section>
<section id="slide-org1cd6a19">
<h3 id="org1cd6a19">Anpassung der Forward Propagation</h3>
<p>
Wir benötigen folgende Werte aus jedem Layer um den Backpropagation Algorithmus ausführen zu können.
</p>
<ul>
<li>\(a\) Aktivation Vektor</li>
<li>\(z\) Pre Activation Function Vektor</li>

</ul>
</section>
<section id="slide-orgee084a8">
<h3 id="orgee084a8">Beschreibung des Algorithmus</h3>
<div class="outline-text-3" id="text-orgee084a8">
</div>
</section>
<section id="slide-orge9df963">
<h4 id="orge9df963">Schritt 1</h4>
<p>
Forward Propagation ausführen.
</p>
</section>
<section id="slide-org4028a66">
<h4 id="org4028a66">Schritt 2</h4>
<p>
Wir berechnen den Gradienten der Cost Function \(J\).
\(J = \frac{1}{2} (y-X)^2 \rightarrow \nabla_y J = X - y\)
</p>
</section>
<section id="slide-orgbf481ad">
<h4 id="orgbf481ad">Schritt 3</h4>
<p>
Erst müssen wir den Gradienten in Relation zu den pre activation function values berechnen.
</p>
<blockquote>
<p>
\(\nabla_{a^{k}} J = g \odot f'(a^{(k)})\)
</p>
</blockquote>
<p>
mit \(f'(x) := Ableitung\ der\ Aktivierungsfunktioin\)
</p>
</section>
<section id="slide-org9096697">
<h4 id="org9096697">Schritt 4</h4>
<p>
Bias Gradienten berechnen.
</p>
<blockquote>
<p>
\(\nabla_{b^{k}} J = g\)
</p>
</blockquote>
<p>
Weight Gradienten berechnen.
</p>
<blockquote>
<p>
\(\nabla_{w^k} J = ga^{k-1}\)
</p>
</blockquote>
</section>
<section id="slide-org7798a60">
<h4 id="org7798a60">Schritt 5</h4>
<p>
\(\nabla a^{k-1} J = w^kg\)
</p>
</section>
<section id="slide-org8747ecc">
<h3 id="org8747ecc">TODO Delta Rule</h3>
<p>
In neural Networks kann der Gradient Descent Algorithmus zu der sog. <b>Delta Rule</b> zusammengefasst werden.
</p>
<aside class="notes">
<p>
\(\lambda\) ist learning rate <br />
\(\alpha\) ist die aktivierungsfunktion <br />
\(z\) ist inputs * weights <br />
</p>

</aside>

<blockquote>
<p>
\[
\nabla w_{ji} = \lambda ( - a) \alpha'(z)a_{L-1}
\]
</p>
</blockquote>
</section>
<section id="slide-orgd615fbe">
<h3 id="orgd615fbe">Praktisches Beispiel in Python</h3>
<div class = "stretch">
     <iframe width="100%" height="100%" src="http://localhost:8888/lab"></iframe>
</div>


</section>
</section>
<section>
<section id="slide-org092a937">
<h2 id="org092a937">Computational Graphs</h2>
<aside class="notes">
<p>
Rechenoperationen in ANN&rsquo;s werden typischerweise nicht in mathematischen Formeln angegeben, sondern in sog. computational Graphs.
</p>

</aside>

<p>
Typischerweise werden Operationen in artificial neural networks nicht mit mathematischen Formeln angegeben, sondern als Graph beschrieben.
</p>

</section>
<section id="slide-orgda1e5a4">
<h3 id="orgda1e5a4">Repräsentation</h3>
<p>
Jede Node in einem Graph \(G\) repräsentiert eine mathematische Operation.<br />
</p>

<p>
Beispielsweise:
</p>
<ul>
<li>Matrix Multiplikation</li>
<li>Addition</li>
<li>Skalare Multiplikation</li>

</ul>
</section>
<section id="slide-org7ea2584">
<h3 id="org7ea2584">Einfache Rechenoperation</h3>
<p>
\[
y = a+b
\]
</p>


<div class="figure">
<p><img src="./basic_graph.png" alt="basic_graph.png" />
</p>
</div>
</section>
<section id="slide-orga2fcce1">
<h3 id="orga2fcce1">Forward Propagation eines Layers</h3>
<p>
\[
a = \sigma(a_{L-1}w+b)
\]
</p>


<div class="figure">
<p><img src="./forward_prop_graph.png" alt="forward_prop_graph.png" />
</p>
</div>

<p>
Backpropagation besteht letztendlich nur darin den Graph in die andere Richtung zu propagieren.
</p>
</section>
</section>
<section>
<section id="slide-org9fc378b">
<h2 id="org9fc378b">General BackPropagation nach Ian Goodfellow</h2>
<p>
Bisher haben wir uns nur mit Backpropagation in Zusammenhang mit neuralen Netzwerken beschäftigt. <br />
Backpropagation kann aber auch generell für andere Anwendungen eingesetzt werden.
</p>
</section>
<section id="slide-org0fa58aa">
<h3 id="org0fa58aa">TODO Operationen</h3>
<p>
Jede Operation wird durch eine Variable repräsentiert. <br />
</p>

</section>
<section id="slide-org4b25d8f">
<h4 id="org4b25d8f">Funktionen</h4>
<aside class="notes">
<p>
<code>get_operation</code> Beispiel bei einer Variable, die durch Matrix Multiplikation generiert wird, würde genau diese Operation zurück gegeben werden.
</p>

</aside>

<p>
Folgende Funktionen werden von Operationen implementiert:
</p>
<ul>
<li><code>get_operation()</code></li>

<li><code>get_consumers()</code> <br />
Gibt alle Variablen/Operationen zurück, die &rsquo;Kinder&rsquo; von sich selber sind.</li>
<li><code>get_inputs()</code> <br />
Gibt alle Variablen/Operationen zurück, die &rsquo;Eltern&rsquo; von sich selber sind.</li>
<li><code>bprop()</code> <br />
Muss bei jeder Operation implementiert werden.</li>

</ul>
</section>
<section id="slide-orgb1d9e81">
<h4 id="orgb1d9e81">Generalisierbarkeit</h4>
<p>
Dadurch ist der Backpropagation Algorithmus sehr allgemein anwendbar.
</p>


</section>
</section>
<section>
<section id="slide-org85e4979">
<h2 id="org85e4979">TODO Laufzeit</h2>

</section>
</section>
<section>
<section id="slide-org25cb20e">
<h2 id="org25cb20e">Quellen</h2>
<ul>
<li>❤️ Deep Learning (Ian Goodfellow, Yoshua Bengio &amp; Aaron Courville)</li>
<li><a href="https://medium.com/@14prakash/back-propagation-is-very-simple-who-made-it-complicated-97b794c97e5c">https://medium.com/@14prakash/back-propagation-is-very-simple-who-made-it-complicated-97b794c97e5c</a></li>
<li>Wikipedia: <a href="https://en.wikipedia.org/wiki/Backpropagation">https://en.wikipedia.org/wiki/Backpropagation</a></li>
<li>Wikipedia: <a href="https://en.wikipedia.org/wiki/Delta_rule">https://en.wikipedia.org/wiki/Delta_rule</a></li>

</ul>
</section>
</section>
</div>
</div>
<script src="reveal/lib/js/head.min.js"></script>
<script src="reveal/js/reveal.js"></script>
<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

controls: true,
progress: true,
history: false,
center: true,
slideNumber: 'c',
rollingLinks: false,
keyboard: true,
mouseWheel: false,
fragmentInURL: false,
hashOneBasedIndex: false,
pdfSeparateFragments: true,

overview: true,

theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
transition: Reveal.getQueryHash().transition || 'convex', // see README of reveal.js for options
transitionSpeed: 'default',

// Optional libraries used to extend reveal.js
dependencies: [
 { src: 'reveal/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: 'reveal/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: 'reveal/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },
 { src: 'reveal/plugin/search/search.js', async: true, condition: function() { return !!document.body.classList; } },
 { src: 'reveal/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } }]

});
</script>
</body>
</html>
