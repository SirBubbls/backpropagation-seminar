<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="utf-8"/>
<title>Backpropagation</title>
<meta name="author" content="Lucas Sas Brunschier"/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="reveal/css/reveal.css"/>

<link rel="stylesheet" href="reveal/css/theme/solarized.css" id="theme"/>

<link rel="stylesheet" href="style.css"/>

<!-- If the query includes 'print-pdf', include the PDF print sheet -->
<script>
    if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = 'reveal/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    }
</script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="sec-title-slide">
<h1 class="title">Backpropagation</h1><h2 class="author">Lucas Sas Brunschier</h2><h2 class="date">SS20</h2>
</section>

<section>
<section id="slide-org73a719e">
<h2 id="org73a719e">Intro</h2>
<p>
Präsentation ist auch online <a href="https://sirbubbls.github.io/backpropagation-seminar">sirbubbls.github.io/backpropagation-seminar</a>
</p>

<p>
Präsentation ist in Org-Mode geschrieben, also sourcen aller Grafiken und
Beispiele sind integriert.
</p>
</section>
<section id="slide-orgd9e6639">
<h3 id="orgd9e6639">Zusätzliche Ressourcen</h3>
<p>
Deep Learning (Ian Goodfellow, Yoshua Bengio &amp; Aaron Courville)
</p>

<div class="figure">
<p><img src="https://images-eu.ssl-images-amazon.com/images/I/610HnULa0dL._SY445_QL70_ML2_.jpg" alt="610HnULa0dL._SY445_QL70_ML2_.jpg" width="150" />
</p>
</div>

<p>
<a href="https://www.deeplearningbook.org">https://www.deeplearningbook.org</a>
</p>

<p>
<a href="https://www.deeplearningbook.org/contents/mlp.html">Back-propagation Kapitel</a>
</p>

</section>
<section id="slide-org2ebad04">
<h3 id="org2ebad04">Jupyter Notebook</h3>
<p>
Beispiele für alle praktischen Beispiele dieser Präsentation sind in diesem <a href="https://github.com/SirBubbls/backpropagation-seminar">Repository</a> zu finden.
</p>

</section>
</section>
<section>
<section id="slide-org2c9a66f">
<h2 id="org2c9a66f">Agenda</h2>
</section>
<section>
<ol>
<li>Vorwissen
<ul>
<li>Gradients &amp; Stochastic Gradient Descent</li>
<li>Computational Graphs</li>

</ul></li>
<li>Neuronale Netze</li>
<li>Forward Propagation</li>
<li>Back-propagation
<ul>
<li>Kettenregel</li>
<li>Back-propagation</li>
<li>Delta Rule</li>
<li>Implementation in Python</li>

</ul></li>
<li>General Back-propagation</li>
<li>Historisches</li>
<li>Quellen</li>

</ol>

</section>
</section>
<section>
<section id="slide-org73564d6">
<h2 id="org73564d6">Vorwissen</h2>
<div class="outline-text-2" id="text-org73564d6">
</div>
</section>
<section id="slide-org1e4c3a7">
<h3 id="org1e4c3a7">Gradient</h3>
<p>
Der Gradient ist der Vektor aller partiellen Ableitungen einer Funktion \(f\).
</p>
<blockquote>
<p>
Notation: \(\nabla f(x)\)
</p>
</blockquote>

</section>
<section id="slide-orgafbe844">
<h4 id="orgafbe844">Beispiel</h4>
<blockquote>
<p>
\(f(x) = 2x_1^2 + x_2^3\)
</p>
</blockquote>
<p>
\(\rightarrow \nabla_xf(x)=\left(\begin{array}{c} f'_{x_1} \\ f'_{x_2} \end{array}\right)= \left(\begin{array}{c} 4x_1 \\ 3x^2_2 \end{array}\right)\)
</p>

</section>
<section id="slide-org5a37f4f">
<h4 id="org5a37f4f">Jacobi Matrix</h4>
<blockquote>
<p>
Bei mehreren Funktionen (o.a. <b>Komponenten Funktionen</b>).
</p>
</blockquote>

<p>
Bei mehreren Funktionen bilden deren Gradienten eine Jacobi Matrix.
</p>

<p>
\[
J(f) =\left (\begin{array}{cc} \nabla f_1 \\ \nabla f_2 \end{array} \right )
\]
</p>

</section>
<section id="slide-org724b164">
<h3 id="org724b164">Stochastic Gradient Descent</h3>
<p>
Der Gradient Descent Algorithmus wird dafür verwendet ein lokales Minimum einer Funktion zu bestimmen.
</p>
</section>
<section id="slide-orge87e898">
<h4 id="orge87e898">Beispiel</h4>
<p>
Funktion \(f(x)=x_1^2-x_2^2\) ist gegeben. <br />
Also: \(\nabla_xf(x)=\left(\begin{array}{c} f'_{x_1} \\ f'_{x_2} \end{array}\right)= \left(\begin{array}{c} 2x_1 \\ -2x_2 \end{array}\right)\) <br />
Wir starten mit einem beliebigen Punkt: z.B. \(\left(\begin{array}{c} 2 \\ 1 \end{array}\right)\) und setzen ein: <br />
\(\left(\begin{array}{c} 2x_1 \\ -2x_2 \end{array}\right) = \left(\begin{array}{c} 2 * 2 \\ -2 * 1 \end{array}\right) = \left(\begin{array}{c} 4 \\ -2 \end{array}\right)\)
</p>

<p>
\(Neuer\ Punkt = \left(\begin{array}{c} 2 \\ 1 \end{array}\right)+ \lambda \left(\begin{array}{c} 4 \\ -2 \end{array}\right)\) mit \(\lambda: learning\ rate\)
</p>

</section>
<section id="slide-orgc4b23c7">
<h3 id="orgc4b23c7">Visualisiert</h3>

<div class="figure">
<p><img src="./gradient_descent.gif" alt="gradient_descent.gif" height="500" />
</p>
</div>

</section>
<section id="slide-orge7c6f74">
<h3 id="orge7c6f74">Computational Graphs</h3>
<aside class="notes">
<p>
Rechenoperationen in ANN&rsquo;s werden typischerweise nicht in mathematischen Formeln angegeben, sondern in sog. computational Graphs.
</p>

</aside>

<p>
Typischerweise werden Operationen in artificial neural networks nicht mit mathematischen Formeln angegeben, sondern als Graph dargestellt.
</p>

</section>
<section id="slide-org34a1281">
<h4 id="org34a1281">Repräsentation</h4>
<p>
Jede Node in einem Graph \(G\) repräsentiert eine mathematische Operation oder eine Input Variable.<br />
</p>

<p>
Beispielsweise:
</p>
<ul>
<li>Matrix Multiplikation</li>
<li>Addition</li>
<li>Skalare Multiplikation</li>

</ul>

</section>
<section id="slide-org89f6463">
<h4 id="org89f6463">Addition Beispiel</h4>
<p>
\[
y = a+b
\]
</p>


<div class="figure">
<p><img src="./basic_graph.png" alt="basic_graph.png" />
</p>
</div>

</section>
<section id="slide-org0340c64">
<h4 id="org0340c64">Komplexere Beispiele</h4>
<p>
\(x=y+z\) <br />
\(a=x\odot z\)
</p>


<div class="figure">
<p><img src="./basic_graph_2.jpg" alt="basic_graph_2.jpg" />
</p>
</div>

</section>
</section>
<section>
<section id="slide-orgfa39abb">
<h2 id="orgfa39abb">Künstliche Neuronale Netze &amp; Deep Learning</h2>
<div class="outline-text-2" id="text-orgfa39abb">
</div>
</section>
<section id="slide-org8a01d1b">
<h3 id="org8a01d1b">Künstliche Neuronale Netze</h3>
<p>
Als Vorbild dienen Neuronale Netze in der Biologie, jedoch sind beide Felder doch unterschiedlicher als man vielleicht erwarten würde.
</p>

<blockquote>
<p>
In diesem Vortrag werden nur fully connected feed forward networks behandelt.
</p>
</blockquote>

</section>
<section id="slide-orgdfdfed1">
<h3 id="orgdfdfed1">Formale Definition</h3>
<blockquote>
<p>
Parameter werden üblicherweise als Theta (\(\theta\)) notiert. <br />
Der Lernalgorithmus soll die Parameter \(\theta\) so verändern, dass sich \(f\) so nah wie möglich an \(f^*\) annähert.
</p>
</blockquote>

<p>
Formale Definition für ein neuronales Netz: \(y=f(x; \theta)\) und \(y = f^*(x)\)
</p>
<ul>
<li>\(y\) ist den Wert den unser NN voraussagen soll</li>
<li>\(x\) sind die Input Daten, die das NN erhält</li>
<li>\(\theta\) sind alle Parameter eines neuronalen Netzwerks</li>
<li>\(f^*\) ist unsere Zielfunktion</li>

</ul>

</section>
<section id="slide-org1a5032c">
<h3 id="org1a5032c">Wie ist nun ein neuronales Netzwerk aufgebaut?</h3>
<aside class="notes">
<p>
In der gezeigten Grafik bilden alle vertikal angeordneten Neuronen einen Layer in einem NN ab.
</p>

</aside>

<p>
Wir teilen das Netzwerk in Schichten (Layer) auf.
</p>


<div class="figure">
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/3d/Neural_network.svg/1200px-Neural_network.svg.png" alt="1200px-Neural_network.svg.png" width="50%" height="50%" />
</p>
</div>

<p>
Jeder Layer bildet eine Funktion \(f^{i}\), mit \(i=Layer\ Index\) ab.
</p>

</section>
<section id="slide-org4e2e9fc">
<h4 id="org4e2e9fc">Formell</h4>
<p>
Somit ist ein neurales Netzwerk eine Kette an Funktionen \(f\).
</p>
<blockquote>
<p>
Ein Netz mit \(3\) Layern wäre somit \(f^2(f^1(f^0(X)))\)
mit \(X=Input\ Data\)
</p>
</blockquote>

</section>
<section id="slide-org837f66a">
<h4 id="org837f66a">Aufbau eines Layers</h4>
<aside class="notes">
<p>
<b>Weights</b> <br />
Jede Kante in einem NN Modell repräsentiert eine reelle Zahl. <br />
Da jedes Neuron mit allen Neuronen des vorherigen Layers verbunden ist, besitzt
jedes Neuron einen Vektor mit der Größe des vorherigen Layers.
Also besitzt jeder Layer eine Weight Matrix mit den Dimensionen \(size(L_{i-1}) \times size(L_i)\)
</p>

</aside>

<p>
Jeder Layer enthält <b>mindestens</b> folgende Informationen:
</p>
<ul>
<li>Eine Weight Matrix (\(w\))</li>
<li>Einen Bias Vektor (\(b\))</li>
<li>Aktivierungsfunktion (\(\sigma\))</li>

</ul>

</section>
<section id="slide-org58b6421">
<h4 id="org58b6421">Verbindung der Layer</h4>
<p>
Jedes Neuron eines Layers \(L_i\) ist mit allen Neuronen des Layers \(L_{i-1}\) verbunden. <br />
</p>


<div class="figure">
<p><img src="./connections.jpg" alt="connections.jpg" />
</p>
</div>

</section>
<section id="slide-org31695cc">
<h4 id="org31695cc">Aktivierungsfunktion</h4>
<aside class="notes">
<p>
Non linearity Functions werden benötigt, da eine zwei lineare Funktionen
immer zu einer weiteren linearen Funktion reduziert werden können. <br />
<b>Ausnahme</b> bei einem Output Layer dessen Output eine reelle Zahl sein soll.
</p>

</aside>

<p>
Da wir bei Neural Networks oft versuchen non-lineare Zusammenhänge zu approximieren, benötigen wir auch eine nicht-lineare Komponente in unserem NN.
</p>

</section>
<section id="slide-org2aa0a86">
<h4 id="org2aa0a86">Beliebte Aktivierungsfunktionen</h4>
<ul>
<li><p>
Rectified Linear Unit (\(ReLU\)) <br />
</p>
<blockquote>
<p>
\(f(x)=max(0, x)\)
</p>
</blockquote></li>
<li><p>
\(Leaky\ ReLU\) <br />
</p>
<blockquote>
<p>
\(f(x)=\begin{cases} x &\quad if\ x > 0 \\ 0.1x &\quad else \end{cases}\)
</p>
</blockquote></li>
<li><p>
Sigmoid Function <br />
</p>
<blockquote>
<p>
\(f(x)= \frac{1}{1+e^{-t}}\)
</p>
</blockquote></li>

</ul>

</section>
<section id="slide-org34ef06b">
<h4 id="org34ef06b">Function Plot</h4>

<div class="figure">
<p><img src="./activation_functions.jpg" alt="activation_functions.jpg" />
</p>
</div>

</section>
<section id="slide-org8a52718">
<h4 id="org8a52718">Cost Function (\(J\))</h4>
<p>
Eine Funktion um zu bestimmen wie &rsquo;nah&rsquo; wir uns an unserem erwarteten Inference Wert befinden.
</p>
<blockquote>
<p>
In dieser Präsentation benutzen wir die Euklidean-Distance \((x-y)^2\) als Cost Function.
</p>
</blockquote>

</section>
</section>
<section>
<section id="slide-org917aaad">
<h2 id="org917aaad">Forward Propagation</h2>
<p>
Ein Layer in einem Feed-Forward Neural Network besteht aus folgenden Elementen:
</p>
<ul>
<li>Inputs (\(X\))</li>
<li>Weights (\(W\))</li>
<li>Biases (\(b\))</li>
<li>Output (\(a\))</li>

</ul>
</section>
<section id="slide-orga93863e">
<h3 id="orga93863e">Berechnung des Inputs</h3>
<p>
Jedes Neuron enthält einen Vektor mit Weights \(w\), der Angibt wie stark jeder Input gewichtet wird. <br />
\(z=a_1*w_1+a_2*w_2\) oder \(z=w^Ta\)
</p>


<div class="figure">
<p><img src="./connections.jpg" alt="connections.jpg" />
</p>
</div>

</section>
<section id="slide-orgbc4c7e0">
<h3 id="orgbc4c7e0">Formell</h3>
<p>
Um die Aktivierungen (\(a\)) eines Layers zu berechen können wir folgende Formel benutzen:
</p>

<blockquote>
<p>
\(a_L = \sigma(a_{L-1} w_L + b_L)\)
</p>
</blockquote>
<p>
Der berechnete Vektor \(a_L\) dient dem Layer \(L+1\) als Input.
</p>

</section>
<section id="slide-org0e78951">
<h3 id="org0e78951">Computational Graph</h3>
<p>
\[
a = \sigma(a_{L-1}w_L+b)
\]
</p>


<div class="figure">
<p><img src="./forward_prop_graph.png" alt="forward_prop_graph.png" />
</p>
</div>

</section>
<section id="slide-org81674c6">
<h3 id="org81674c6">Beispiel (XOR)</h3>
<p>
\(W=\left[\begin{array}{ccc} 1 & 1 \\ 1 & 1 \end{array}\right]\) <br />
\(b=\left [\begin{array}{ccc} 0 \\ -1 \end{array} \right]\) <br />
</p>
</section>
<section id="slide-org05a1dd7">
<h3 id="org05a1dd7">Multiplizieren der Weights (\(W\)) und Inputs (\(X\))</h3>
<p>
\[
XW=\left[\begin{array}{ccc} 0 & 0 \\ 0 & 1 \\ 1 & 0 \\ 1 & 1 \end{array} \right]
\left[\begin{array}{ccc} 1 & 1 \\ 1 & 1 \end{array}\right]=
\left[\begin{array}{ccc} 0 & 0 \\ 1 & 1 \\ 1 & 1 \\ 2 & 2 \end{array} \right]
\]
</p>

</section>
<section id="slide-orge4cef9e">
<h3 id="orge4cef9e">Addieren des Bias Vektors (\(b\))</h3>
<p>
\[
XW + b=
\left[\begin{array}{ccc} 0 & 0 \\ 1 & 1 \\ 1 & 1 \\ 2 & 2 \end{array} \right] +
\left(\begin{array}{ccc} 0 \\ -1 \end{array}\right)=
\left[\begin{array}{ccc} 0 & -1 \\ 1 & 0 \\ 1 & 0 \\ 2 & 1 \end{array} \right]
\]
</p>
</section>
<section id="slide-org8ed42b4">
<h3 id="org8ed42b4">Aktivierungsfunktion (in diesem Fall \(ReLU\))</h3>
<blockquote>
<p>
\(ReLU:= f(x)=max(0, x)\)
</p>
</blockquote>
<p>
\[
relu(XW+b)=
relu(\left[\begin{array}{ccc} 0 & -1 \\ 1 & 0 \\ 1 & 0 \\ 2 & 1 \end{array} \right])=
\left[\begin{array}{ccc} 0 & 0 \\ 1 & 0 \\ 1 & 0 \\ 2 & 1 \end{array} \right]
\]
</p>

<p>
Die Aktivierungsfunktion wird auf jedes Element der Matrix ausgeführt.
</p>

</section>
<section id="slide-org3e9666a">
<h3 id="org3e9666a">Output Layer</h3>
<p>
Multiplizieren der Output Matrix des ersten Layers mit den Weights des Output Layers (\(w\)).
\[
w= relu(XW+b)* \left[\begin{array}{ccc} 1 \\ -2 \end{array}\right]=
\left[\begin{array}{ccc} 0 & 0 \\ 1 & 0 \\ 1 & 0 \\ 2 & 1 \end{array} \right]*
\left[\begin{array}{ccc} 1 \\ -2 \end{array}\right]=
\left[\begin{array}{ccc} 0 \\ 1 \\ 1 \\ 0 \end{array}\right]
\]
</p>

</section>
<section id="slide-org14ab293">
<h3 id="org14ab293">Predictions &amp; Input</h3>
<p>
Input: \(\left[\begin{array}{ccc} 0 & 0 \\ 0 & 1 \\ 1 & 0 \\ 1 & 1 \end{array} \right]\) <br />
Predictions: \(\left[\begin{array}{ccc} 0 \\ 1 \\ 1 \\ 0 \end{array}\right]\)
</p>

</section>
<section id="slide-org7794766">
<h3 id="org7794766">Code Beispiel</h3>
<div class="org-src-container">

<pre  class="src src-python"><span style="color: #fb2874;">def</span> <span style="color: #b6e63e;">forward</span>(X):
    <span style="color: #fd971f;">a</span> = X
    <span style="color: #fb2874;">for</span> layer <span style="color: #fb2874;">in</span> L:
        <span style="color: #fd971f;">a</span> = h @ layer.weights + layer.bias
    <span style="color: #fb2874;">return</span> a
</pre>
</div>

</section>
<section id="slide-org2a99f6f">
<h3 id="org2a99f6f">Laufzeitkomplexität</h3>
<aside class="notes">
<p>
Wir multiplizieren jedes Weight und addieren einen Bias Wert.
</p>

</aside>

<blockquote>
<p>
\[
O(w)
\]
</p>
</blockquote>

<ul>
<li>\(w\) Anzahl der Weights in neuronalem Netz.</li>

</ul>

</section>
</section>
<section>
<section id="slide-orga87257f">
<h2 id="orga87257f">Backpropagation</h2>
<div class="outline-text-2" id="text-orga87257f">
</div>
</section>
<section id="slide-orgcaab68c">
<h3 id="orgcaab68c">Wozu brauchen wir den Back-propagation Algorithmus?</h3>
<aside class="notes">
<p>
Gesuchte Gradients:
</p>
<ul>
<li>Ableitung von \(J\) in Abhängigkeit von Bias \(b^k\)</li>
<li>Ableitung von \(J\) in Abhängigkeit von Weights \(w^k\)</li>

</ul>

</aside>

<p>
Ein fundamentaler Baustein, von neuralen Netzen.
</p>

<p>
Back-propagation ist kein Lernalgorithmus/Optimierungsalgorithmus, sondern aussschlißlich für die Generierung der Gradients jedes Layers zuständig.
</p>

<p>
Also suchen wir folgende Gradients:
</p>
<ul>
<li>\(\nabla_{b^k} J\)</li>
<li>\(\nabla_{w^k} J\)</li>

</ul>

</section>
<section id="slide-orgb0b7ac8">
<h3 id="orgb0b7ac8">Kettenregel</h3>
<aside class="notes">
<p>
Da ein NN prinzipiell nur viele geschachtelte Funktionen sind ist die Kettenregel sehr nützlich um die Ableitungen für jede Funktion zu bestimmen.
</p>

</aside>

<p>
Die Kettenregel ist nützlich um Ableitungen aus schon bereits vorhandenen Ableitungen zu konstruieren.
</p>

<p>
\[y=g(x)\ und\ z=f(g(x))=f(y)\]
</p>

<p>
Dann besagt die Kettenregel: \(\frac{dz}{dx} = \frac{dz}{dy} \frac{dy}{dx}\)
</p>

</section>
<section id="slide-orgd81caba">
<h3 id="orgd81caba">Kettenregel als Graph</h3>
<aside class="notes">
<p>
An der Formel \(f'(f(f(w)))f'(f(w))f'(w)\) erkennt man, dass immer die Zwischenergebnisse aus jedem Schritt benötigt werden um die korrekte Ableitung \(\frac{\partial z}{\partial w}\) zu bestimmen.
</p>

</aside>

<p>
\[
x = f(w),\ y=f(x),\ z=f(y)
\]
</p>


<div class="figure">
<p><img src="./chain_rule_derriv.jpg" alt="chain_rule_derriv.jpg" />
</p>
</div>

<p>
\[
\frac{\partial z}{\partial w}=
\frac{\partial z}{\partial y}
\frac{\partial y}{\partial x}
\frac{\partial x}{\partial w}
=
f'(y)f'(x)f'(w) \\
= f'(f(f(w)))f'(f(w))f'(w)
\]
</p>

</section>
<section id="slide-org0664a6d">
<h3 id="org0664a6d">Anpassung der Forward Propagation</h3>
<aside class="notes">
<p>
Wie davor gezeigt müssen wir nun Zwischenergebnisse aus der Forward Progagation speichern um im Anschluss effizient die Back-propagation durchführen zu können.
Eine Alternative ist bei <b>limitiertem Speicher</b> die Zwischenergebnisse immer neu zu evaluieren, wenn sie benötigt werden. (-&gt; Höhere Laufzeit)
</p>

</aside>

<p>
Wir benötigen folgende Werte aus jedem Layer um den Back-propagation Algorithmus ausführen zu können.
</p>
<ul>
<li>\(a\) Aktivation Vektor</li>
<li>\(z\) Pre Activation Function Vektor</li>

</ul>

<blockquote>
<p>
\(f'(y)f'(x)f'(w)\): Speichern der Zwischenergebnisse in Variablen
\(f'(f(f(w)))f'(f(w))f'(w)\): Neu Evaluierung der Zwischenergebnisse
</p>
</blockquote>
</section>
<section id="slide-org2474a1c">
<h3 id="org2474a1c">Beschreibung des Algorithmus</h3>
<div class="outline-text-3" id="text-org2474a1c">
</div>
</section>
<section id="slide-orgfbd0aa8">
<h4 id="orgfbd0aa8">Schritt 1</h4>
<p>
Forward Propagation ausführen.
</p>
</section>
<section id="slide-orgede4356">
<h4 id="orgede4356">Schritt 2</h4>
<p>
Wir berechnen den Gradienten der Cost Function \(J\).
\(J = \frac{1}{2} (y-X)^2 \rightarrow \nabla_y J = X - y\)
</p>
</section>
<section id="slide-org673ac1e">
<h4 id="org673ac1e">Schritt 3</h4>
<p>
Erst müssen wir den Gradienten in Relation zu den pre activation function values berechnen.
</p>
<blockquote>
<p>
\(\nabla_{a^{k}} J = g \odot f'(a^{(k)})\)
</p>
</blockquote>
<p>
mit \(f'(x) := Ableitung\ der\ Aktivierungsfunktioin\)
</p>
</section>
<section id="slide-org4f7acb0">
<h4 id="org4f7acb0">Schritt 4</h4>
<p>
Weight Gradienten berechnen.
\[
f(w, a, b) = w*a+b
\]
\(g * \frac{\partial}{\partial w} = g * (a+0)\)
</p>

<blockquote>
<p>
\(\nabla_{w^k} J = ga^{k-1}\)
</p>
</blockquote>

</section>
<section id="slide-orgb0b5f5e">
<h4 id="orgb0b5f5e">Schritt 5</h4>
<p>
Bias Gradienten berechnen.
\[
f(w, a, b) = w*a+b
\]
\(g * \frac{\partial}{\partial b}= g * 1\)
</p>

<blockquote>
<p>
\(\nabla_{b^{k}} J = g\)
</p>
</blockquote>

</section>
<section id="slide-org33df73f">
<h4 id="org33df73f">Schritt 6</h4>
<p>
\(\nabla a^{k-1} J = w^kg\)
</p>
</section>
<section id="slide-orgd6c3df0">
<h4 id="orgd6c3df0">Wiederholen von Schritt 3 - 5 des nächsten Layers (\(L{-1}\))</h4>
</section>
<section id="slide-org5d501dc">
<h3 id="org5d501dc">Graph</h3>
<aside class="notes">
<p>
Wir bilden einen Pfad (von Hinten nach Vorne) an Pfeilen zu einem Gradienten einer Node die wir berechnen wollen.
Wir multiplizieren alle partiellen Ableitungen auf dem Weg dahin miteinander.
</p>

</aside>


<div class="figure">
<p><img src="./backprop_derriv.jpg" alt="backprop_derriv.jpg" />
</p>
</div>

</section>
<section id="slide-org1efd628">
<h3 id="org1efd628">Delta Rule</h3>
<p>
In neural Networks kann der Back-propagation Algorithmus zu der sog. <b>Delta Rule</b> zusammengefasst werden.
</p>
<aside class="notes">
<p>
\(\lambda\) ist learning rate <br />
\(\alpha\) ist die Aktivierungsfunktion <br />
\(z\) ist inputs * weights <br />
</p>

</aside>

<blockquote>
<p>
\[
\nabla w_{ji} = \lambda ( - a) \alpha'(z)a_{L-1}
\]
</p>
</blockquote>

</section>
<section id="slide-org9da577f">
<h3 id="org9da577f">Praktisches Beispiel in Python</h3>
<p>
<a href="https://github.com/SirBubbls/backpropagation-seminar/blob/master/Backpropagation.ipynb">Notebook</a>
</p>
<div class = "stretch">
     <iframe width="100%" height="100%" src="http://localhost:8888/lab"></iframe>
</div>
</section>
<section id="slide-org5d93ad6">
<h4 id="org5d93ad6">Mini Batch Training</h4>
<aside class="notes">
<p>
Keine Vektoren sondern mehrere Datenpunkte in Form einer Matrix (ein Vektor aus Vektoren (Inputs)).
</p>

</aside>

<p>
In der Praxis werden keine Vektoren als Input Daten benutzt, sondern Matrizen (siehe <code>XOR</code> Beispiel).
\[
Input = \left[\begin{array}{ccc} 0 & 0 \\ 0 & 1 \\ 1 & 0 \\ 1 & 1 \end{array} \right]
\]
</p>

<p>
Wir erhalten nun auch mehrere Gradienten in Form einer Matrix. Wir können nun den Durchschnitt der Gradienten nutzen um unsere Weights anzupassen.
</p>
</section>
<section id="slide-orgc3ce601">
<h4 id="orgc3ce601">Iris Dataset</h4>
<p>
<a href="https://github.com/SirBubbls/backpropagation-seminar/blob/master/MiniBatch.ipynb">Notebook</a>
</p>

<div class="figure">
<p><img src="./dataset.jpg" alt="dataset.jpg" height="500" />
</p>
</div>
</section>
<section id="slide-orgb63645a">
<h4 id="orgb63645a">Low Learning Rate</h4>

<div class="figure">
<p><img src="./low_learning_rate.gif" alt="low_learning_rate.gif" height="550" />
</p>
</div>

</section>
<section id="slide-org8915b43">
<h4 id="org8915b43">High Learning Rate</h4>

<div class="figure">
<p><img src="./high_learning_rate.gif" alt="high_learning_rate.gif" height="550" />
</p>
</div>

</section>
<section id="slide-org3a24b48">
<h3 id="org3a24b48">Komplexität</h3>
<blockquote>
<p>
<b>Wichtig</b> <br />
Folgende Komplexitäten beziehen sich ausschließlich auf den Backpropagation Algorithmus.
</p>
</blockquote>

</section>
<section id="slide-org433d590">
<h4 id="org433d590">Laufzeitkomplexität</h4>
<aside class="notes">
<p>
Wir multiplizieren die transponierte Weight Matrix also die gleiche Komplexität wie
Forward-propagation.
</p>

</aside>

<p>
Back-propagation besitzt die gleiche Laufzeitkomplexität wie Forward-propagation.
</p>

<blockquote>
<p>
\[
O(w)
\]
</p>
</blockquote>

<ul>
<li>\(w\) Anzahl der Weights in neuronalem Netz.</li>

</ul>

</section>
<section id="slide-org26723ba">
<h4 id="org26723ba">Speicherkomplexität</h4>
<blockquote>
<p>
\[
O(mh)
\]
</p>
</blockquote>

<ul>
<li>\(m\) Anzahl an Elementen in Batch</li>
<li>\(h\) Anzahl der Hidden-Units</li>

</ul>


</section>
</section>
<section>
<section id="slide-org79bf93c">
<h2 id="org79bf93c">General Back-propagation</h2>
<p>
Bisher haben wir uns nur mit Back-propagation in Zusammenhang mit neuronalen Netzwerken beschäftigt. <br />
Back-propagation kann aber auch generell für andere Anwendungen eingesetzt werden.
</p>

</section>
<section id="slide-org9fc8bef">
<h3 id="org9fc8bef">Symbol to Number / Symbol to Symbol</h3>
<p>
Es existieren zwei verschiedene Möglichkeiten die Berechnungen der Gradients durchzuführen.
</p>

<ul>
<li>Symbol to Number</li>
<li>Symbol to Symbol</li>

</ul>

</section>
<section id="slide-org2163d80">
<h4 id="org2163d80">Symbol to Number</h4>
<aside class="notes">
<p>
Methode die wir in vorherigen Beispielen verwendet waren.
</p>

</aside>

<p>
Die Input Variablen werden durch Zahlenwerte ersetzt und daraufhin (wie besprochen) alle nötigen Gradienten berechnet.
</p>

</section>
<section id="slide-org1c1fb4b">
<h4 id="org1c1fb4b">Symbol to Symbol</h4>
<aside class="notes">
<p>
Symbol to Symbol benötigt zum differenzieren keine eigentlichen Zahlenwerte, sondern ersetzt diese durch Symbole. <br />
Zusammengefasst kann man sagen, dass der Symbol to Number approach nur die Berechnungen ausführt die vom Symbol to Symbol als Graph erstellt werden.
</p>

</aside>

<p>
Beim der Symbol to Symbol Herangehensweise wird zuerst der Graph mit allen Ableitungen mit der Hilfe von symbolischen Werten konstruiert. <br />
Später wird dann der Graph mit der Hilfe eines eigenen Algorithmus ausgewertet. <br />
</p>

<blockquote>
<p>
<b>Vorteil</b> <br />
Ableitungen eines höheren Grads können berechnet werden, indem man den Back-propagation Algorithmus auf einen bereits abgeleiteten Graphen ausführt.
</p>
</blockquote>

</section>
<section id="slide-org8734596">
<h3 id="org8734596">Operationen</h3>
<aside class="notes">
<p>
Wir benutzen Tensoren um eine möglichst generelle Definition des Algorithmus zu beschreiben.
</p>

</aside>
<p>
Wir betrachten einen computational Graph, jede Node in dem Graph repräsentiert eine Variable in Form eines Tensors.
</p>

</section>
<section id="slide-orgf744594">
<h4 id="orgf744594">Funktionen</h4>
<aside class="notes">
<p>
<code>get_operation</code> Beispiel bei einer Variable, die durch Matrix Multiplikation generiert wird, würde genau diese Operation zurück gegeben werden.
</p>

</aside>

<ul>
<li><code>get_operation()</code></li>
<li><code>get_consumers()</code> <br />
Gibt alle Variablen/Operationen zurück, die &rsquo;Kinder&rsquo; von sich selber sind.</li>
<li><code>get_inputs()</code> <br />
Gibt alle Variablen/Operationen zurück, die &rsquo;Eltern&rsquo; von sich selber sind.</li>
<li><code>bprop()</code> <br />
Muss bei jeder Operation implementiert werden.</li>

</ul>
</section>
<section id="slide-org15c2f87">
<h3 id="org15c2f87">Algorithmus</h3>
<p>
Benötigt ist:
</p>
<ul>
<li>die Menge aller Variablen \(T\), deren Gradienten wir berechnen müssen</li>
<li>den Graphen \(G\)</li>
<li>die Variable \(z\), die wir differenzieren wollen</li>

</ul>

</section>
<section id="slide-org4985a1c">
<h4 id="org4985a1c">Äußere Funktion</h4>
<p>
Wir definieren \(G'\) als alle Variablen, die Vorfahren von \(z\), oder Nachfahren von \(T\) sind. <br />
<br />
In <code>grad_table</code> können wir Variablen Gradients zuweisen. <br />
</p>

<p>
<code>grad_table[z] = 1</code>   (da \(\frac{\partial z}{\partial z} = 1\))
</p>

</section>
<section id="slide-org42e4446">
<h4 id="org42e4446">Loop über alle Variablen, deren Gradienten wir berechnen müssen</h4>
<p>
In jedem Loop rufen wir die Funktion <code>build_grad</code> auf.
</p>
<div class="org-src-container">

<pre  class="src src-python"><span style="color: #fb2874;">for</span> v <span style="color: #fb2874;">in</span> T:
    build_grad(v, G, G_1, grad_table)
<span style="color: #fb2874;">return</span> [grad_table[v] <span style="color: #fb2874;">for</span> v <span style="color: #fb2874;">in</span> T]
</pre>
</div>

</section>
<section id="slide-org1a41770">
<h4 id="org1a41770"><code>build_grad(v, G, G_1, grad_table)</code></h4>
<div class="org-src-container">

<pre  class="src src-python"><span style="color: #fb2874;">def</span> <span style="color: #b6e63e;">build_grad</span>(v, G, G_1, grad_table):
    <span style="color: #fb2874;">if</span> v <span style="color: #fb2874;">in</span> grad_table: <span style="color: #fb2874;">return</span> grad_table[v]
    <span style="color: #fd971f;">i</span> = <span style="color: #9c91e4; font-weight: bold;">1</span>
    <span style="color: #fb2874;">for</span> c <span style="color: #fb2874;">in</span> get_consumers(V, G_1):
        <span style="color: #fd971f;">op</span> = get_operation(c)
        <span style="color: #fd971f;">d</span> = build_grad(c, G, G_1, grad_table)
        <span style="color: #fd971f;">g</span>[i] = op.bprop(get_inputs(c, G_1), v, d)
        <span style="color: #fd971f;">i</span> += <span style="color: #9c91e4; font-weight: bold;">1</span>
    <span style="color: #fd971f;">g</span> = <span style="color: #fd971f;">sum</span>(g)
    <span style="color: #fd971f;">grad_table</span>[v] = g
    <span style="color: #fb2874;">return</span> g
</pre>
</div>

</section>
<section id="slide-orgcefe2fe">
<h4 id="orgcefe2fe"><code>bprop</code> Funktion</h4>
<p>
<code>op.bprop(inputs, X, G)</code> <br />
 <br />
<code>inputs</code>: Liste an Inputs, die wir der Operation zur Verfügung stellen <br />
<code>X</code>: Input, dessen Ableitung wir berechnen wollen <br />
<code>G</code>: Gradient des Outputs der Operation
</p>

</section>
<section id="slide-org93ac0e2">
<h3 id="org93ac0e2">Beispiel</h3>
<div class="outline-text-3" id="text-org93ac0e2">
</div>
</section>
<section id="slide-org460257e">
<h4 id="org460257e">Graph</h4>

<div class="figure">
<p><img src="./big_graph_1.jpg" alt="big_graph_1.jpg" />
</p>
</div>

</section>
<section id="slide-orgda957b2">
<h4 id="orgda957b2">Bestimmen der Ableitung \(\frac{\partial u_1}{\partial u_4}\)</h4>

<div class="figure">
<p><img src="./big_graph_2.jpg" alt="big_graph_2.jpg" />
</p>
</div>

</section>
<section id="slide-org9ce897e">
<h4 id="org9ce897e">Eintragen aller Ableitungen in Graph</h4>

<div class="figure">
<p><img src="./big_graph_3.jpg" alt="big_graph_3.jpg" />
</p>
</div>

</section>
<section id="slide-org8d88b58">
<h3 id="org8d88b58">Generalisierbarkeit</h3>
<p>
Dadurch ist der Back-propagation Algorithmus sehr allgemein anwendbar. <br />
</p>

<p>
Jede Operation ist für seine eigene Differenzierung verantwortlich und benötigt keine weiteren Informationen.
</p>

</section>
</section>
<section>
<section id="slide-orgf11320b">
<h2 id="orgf11320b">Historisches</h2>
<aside class="notes">
<p>
Die Kettenregel stammt aus dem 17ten Jahrhundert.
</p>

</aside>

<ul>
<li>Kettenregel stammt aus dem 17ten Jahrhundert (Leibniz, 1676). <br /></li>
<li>Lineare neurale Netzwerke Mitte des 20ten Jahrhunderts. <br /></li>
<li>Erfolgreiche Experimente mit Back-Propagation (1986) <br /></li>

</ul>

</section>
<section id="slide-org760e8ae">
<h4 id="org760e8ae">Popularität von neuronalen Netzen</h4>
<aside class="notes">
<p>
Durch die Erfolge mit Back-propagation wurde Anfang der 90er Jahre Deep Learning vermehrt eingesetzt. <br />
Klassische machine learning Algorithmen wurden in den 90er Jahren mehr genutzt als neuronale Netzwerke.
</p>

</aside>

<p>
Klassische machine learning Algorithmen wurden in den 90er Jahren mehr genutzt als neuronale Netzwerke.
</p>

<p>
Durch die hohe Speicheranforderung wurden NN ab ca. 2006 immer vermehrter eingesetzt und
bilden heute einen fundamentalen Baustein von maschinellem Lernen.
</p>

</section>
<section id="slide-org9b2c101">
<h4 id="org9b2c101">Back-propagation &amp; Gradient Descent</h4>
<p>
Beide treibenden Algorithmen von neuronalen Netzwerken haben sich seit den 80er Jahren nicht wesentlich verändert. <br />
</p>

<p>
Bessere Resultate sind besser Hardware und Dataset Optimierung zu verdanken.
</p>

</section>
</section>
<section>
<section id="slide-orgd9ea149">
<h2 id="orgd9ea149">Quellen</h2>
<ul>
<li>Deep Learning (Ian Goodfellow, Yoshua Bengio &amp; Aaron Courville)</li>
<li><a href="https://medium.com/@14prakash/back-propagation-is-very-simple-who-made-it-complicated-97b794c97e5c">https://medium.com/@14prakash/back-propagation-is-very-simple-who-made-it-complicated-97b794c97e5c</a></li>
<li>Wikipedia: <a href="https://en.wikipedia.org/wiki/Backpropagation">https://en.wikipedia.org/wiki/Backpropagation</a></li>
<li>Wikipedia: <a href="https://en.wikipedia.org/wiki/Delta_rule">https://en.wikipedia.org/wiki/Delta_rule</a></li>

</ul>
</section>
</section>
</div>
</div>
<script src="reveal/lib/js/head.min.js"></script>
<script src="reveal/js/reveal.js"></script>
<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

controls: true,
progress: true,
history: false,
center: true,
slideNumber: 'c',
rollingLinks: false,
keyboard: true,
mouseWheel: false,
fragmentInURL: false,
hashOneBasedIndex: false,
pdfSeparateFragments: true,

overview: true,

theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
transition: Reveal.getQueryHash().transition || 'convex', // see README of reveal.js for options
transitionSpeed: 'default',

// Optional libraries used to extend reveal.js
dependencies: [
 { src: 'reveal/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: 'reveal/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: 'reveal/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },
 { src: 'reveal/plugin/search/search.js', async: true, condition: function() { return !!document.body.classList; } },
 { src: 'reveal/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } }]

});
</script>
</body>
</html>
